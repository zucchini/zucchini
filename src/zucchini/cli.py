from pathlib import Path
import sys
from typing import Literal
from cyclopts import App

from .gradescope import GradescopeAutograderOutput, GradescopeAutograderZip, GradescopeMetadata
from .grading_manager import Grade
from .local_grading import LocalAutograderOutput
from .submission import Submission
from .zucchini import ZucchiniState

app = App(
    help="A fun autograder management system for the whole family.",
    help_format="md",
    help_formatter="plain",
    help_on_error=True,
)
state = ZucchiniState(assignment_directory=Path("."))
@app.command
def grade(
    submission_path: Path = Path("/autograder/submission")
):
    """
    Grades a submission, located at the specified submission path.

    Parameters
    ----------
    submission_path : Path, optional
        The path of the submission as generated by Gradescope.
    """
    assignment = state.get_assignment()

    submission = Submission.load_from_raw_files(assignment, submission_path)
    grade = Grade(assignment, submission)
    grade.grade()
    
    grade.dump_component_grades(sys.stdout)

@app.command()
def export(
    format_: Literal["text", "gradescope"],
    metadata_path: Path | None = Path("/autograder/submission_metadata.json")
):
    """
    Convert component grades to some format JSON.

    Bridge the gap between component results provided obtained with
    `zucc grade-submission' (plus Gradescope submission metadata) and a
    Gradescope JSON result. Will read component grades JSON from stdin
    and spit out Gradescope JSON on stdout.

    FIXME: old format
    Usual usage:
    zucc grade-submission /autograder/submission \\
        | zucc gradescope bridge /autograder/submission_metadata.json \\
        >/autograder/results/results.json
    """
    assignment = state.get_assignment()

    if format_ == "text":
        submission = Submission.load_from_component_grades_json(
            assignment, component_grades_fp=sys.stdin)
        grade = Grade(assignment, submission)
        output = LocalAutograderOutput.from_grade(grade)

        print(output)
    elif format_ == "gradescope":
        metadata = GradescopeMetadata.from_json_path(metadata_path)

        late_deltatime = metadata.submission_date - metadata.due_date
        seconds_late = max(int(late_deltatime.total_seconds()), 0)

        submission = Submission.load_from_component_grades_json(
            assignment, seconds_late=seconds_late, component_grades_fp=sys.stdin)
        submission.student_name = metadata.student_name
        grade = Grade(assignment, submission, max_score=metadata.total_points)

        output = GradescopeAutograderOutput.from_grade(grade)
        output.to_json_stream(sys.stdout)
    else:
        raise ValueError(f"Invalid format {format_!r}")

@app.command()
def generate(
    format_: Literal["gradescope_zip", "gradescope_docker"],
    out_path: Path,
    wheel_path: Path,
):
    if format_ == "gradescope_zip":
        assignment = state.get_assignment()
        autograder_zip = GradescopeAutograderZip(
            path=state.assignment_directory,
            prerequisites=assignment.list_prerequisites(),
            extra_setup_commands=assignment
                                    .list_extra_setup_commands(),
            needs_display=assignment.needs_display(),
            wheel_path=wheel_path)
        autograder_zip.write_zip(out_path)
    elif format_ == "gradescope_docker":
        raise NotImplementedError()
    else:
        raise ValueError(f"Invalid template format {format_!r}")
    pass

if __name__ == "__main__":
    app()