from fractions import Fraction
from pathlib import Path
import sys
from typing import Literal
from cyclopts import App
import tomli

from .assignment import Assignment2
from .grades import AssignmentGrade2
from .gradescope_model import GradescopeMetadata2
from .gradescope_output_model import GradescopeOutput
from .model import AssignmentConfig, AssignmentMetadata

from .local_grading import LocalAutograderOutput2
from .submission import Submission2
from .zucchini import ZucchiniState

app = App(
    help="A fun autograder management system for the whole family.",
    help_format="md",
    help_formatter="plain",
    help_on_error=True,
)
state = ZucchiniState(assignment_directory=Path("."))
ASSIGNMENT_DIR = Path(".")

@app.command
def grade(
    submission_path: Path = Path("/autograder/submission")
):
    """
    Grades a submission, located at the specified submission path.

    Parameters
    ----------
    submission_path : Path, optional
        The path of the submission as generated by Gradescope.
    """
    # TODO: Don't hardcode these
    GRADESCOPE_METADATA_FP = "/autograder/metadata"
    ASSIGNMENT_CONFIG_FILE = "zucchini.toml"

    # Load assignment
    try:
        with open(GRADESCOPE_METADATA_FP, "rb") as f:
            gs_metadata = GradescopeMetadata2.model_validate_json(f.read())
            metadata = gs_metadata.as_metadata(submission_path)
            created_at = gs_metadata.created_at
    except FileNotFoundError:
        metadata = AssignmentMetadata(total_points=Fraction(100), tester_dir=ASSIGNMENT_DIR)
        created_at = None

    with open(ASSIGNMENT_DIR / ASSIGNMENT_CONFIG_FILE, "rb") as f:
        data = tomli.load(f)
        config = AssignmentConfig.model_validate(data)

    assignment = Assignment2(config, metadata)
    submission = Submission2(submission_path, created_at)

    grade = assignment.grade(submission)
    print(grade.model_dump_json())

@app.command()
def export(
    format_: Literal["text", "gradescope"],
    metadata_path: Path | None = Path("/autograder/submission_metadata.json")
):
    """
    Convert component grades to some format JSON.

    Bridge the gap between component results provided obtained with
    `zucc grade-submission' (plus Gradescope submission metadata) and a
    Gradescope JSON result. Will read component grades JSON from stdin
    and spit out Gradescope JSON on stdout.

    FIXME: old format
    Usual usage:
    zucc grade-submission /autograder/submission \\
        | zucc gradescope bridge /autograder/submission_metadata.json \\
        >/autograder/results/results.json
    """
    grade = AssignmentGrade2.model_validate_json(sys.stdin.read())

    if format_ == "text":
        output = LocalAutograderOutput2.from_grade(grade)
        print(output)
    elif format_ == "gradescope":
        output = GradescopeOutput.from_grade(grade)
        print(output.model_dump_json())
    else:
        raise ValueError(f"Invalid format {format_!r}")

# @app.command()
# def generate(
#     format_: Literal["gradescope_zip", "gradescope_docker"],
#     out_path: Path,
#     wheel_path: Path,
# ):
#     if format_ == "gradescope_zip":
#         assignment = state.get_assignment()
#         autograder_zip = GradescopeAutograderZip(
#             path=state.assignment_directory,
#             prerequisites=assignment.list_prerequisites(),
#             extra_setup_commands=assignment
#                                     .list_extra_setup_commands(),
#             needs_display=assignment.needs_display(),
#             wheel_path=wheel_path)
#         autograder_zip.write_zip(out_path)
#     elif format_ == "gradescope_docker":
#         raise NotImplementedError()
#     else:
#         raise ValueError(f"Invalid template format {format_!r}")
#     pass

if __name__ == "__main__":
    app()